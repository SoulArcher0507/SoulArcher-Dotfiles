#!/bin/bash
set -euo pipefail

# ===== Config =====
WALLPAPER="${1:-}"                                  # opzionale
WAYBAR_CSS="$HOME/.config/waybar/colors.css"
SWAYNC_CSS="$HOME/.config/swaync/colors.css"
WLOGOUT_CSS="$HOME/.config/wlogout/colors.css"
ROFI_RASI="$HOME/.config/rofi/colors.rasi"
HYPR_CONF="$HOME/.config/hypr/colors.conf"
QS_JSON="$HOME/.config/quickshell/colors.json"

WAL_CACHE_JSON="$HOME/.cache/wal/colors.json"
WAL_ROFI_RASI_DARK="$HOME/.cache/wal/colors-rofi-dark.rasi"
WAL_ROFI_RASI_LIGHT="$HOME/.cache/wal/colors-rofi-light.rasi"

# ===== Dep checks =====
need() { command -v "$1" >/dev/null 2>&1 || { echo "Errore: manca '$1'"; exit 1; }; }
need wal
need jq

# ===== Palette generation =====
if [[ -n "$WALLPAPER" ]]; then
  if [[ ! -f "$WALLPAPER" ]]; then
    echo "Errore: wallpaper non trovato: $WALLPAPER" >&2
    exit 1
  fi
  # Genera la palette da wallpaper (non usiamo -n per rispettare il tuo comportamento originale)
  wal -i "$WALLPAPER"
else
  # Nessun argomento: ricarica l'ultima palette generata da wal (non cambia wallpaper)
  wal -R
fi

# Verifica che wal abbia prodotto il JSON
if [[ ! -f "$WAL_CACHE_JSON" ]]; then
  echo "Errore: wal non ha generato $WAL_CACHE_JSON" >&2
  exit 1
fi

# ===== Helpers =====
hex_to_rgb_triplet() {
  # input: "#RRGGBB" -> output: "R,G,B"
  local HEX="${1#\#}"
  local R="${HEX:0:2}" G="${HEX:2:2}" B="${HEX:4:2}"
  printf "%d,%d,%d" "0x$R" "0x$G" "0x$B"
}
atomic_write() {
  # $1 path, stdin->temp->mv
  local dst="$1"
  mkdir -p "$(dirname "$dst")"
  local tmp
  tmp="$(mktemp "${dst}.XXXXXX")"
  cat >"$tmp"
  mv -f "$tmp" "$dst"
}

# ===== Leggi palette wal =====
bg="$(jq -r '.special.background' "$WAL_CACHE_JSON")"
fg="$(jq -r '.special.foreground' "$WAL_CACHE_JSON")"
cursor="$(jq -r '.special.cursor' "$WAL_CACHE_JSON")"

c0="$(jq -r '.colors.color0'  "$WAL_CACHE_JSON")"
c1="$(jq -r '.colors.color1'  "$WAL_CACHE_JSON")"
c2="$(jq -r '.colors.color2'  "$WAL_CACHE_JSON")"
c3="$(jq -r '.colors.color3'  "$WAL_CACHE_JSON")"
c4="$(jq -r '.colors.color4'  "$WAL_CACHE_JSON")"   # usato spesso come accent
c5="$(jq -r '.colors.color5'  "$WAL_CACHE_JSON")"
c6="$(jq -r '.colors.color6'  "$WAL_CACHE_JSON")"
c7="$(jq -r '.colors.color7'  "$WAL_CACHE_JSON")"
c8="$(jq -r '.colors.color8'  "$WAL_CACHE_JSON")"
c9="$(jq -r '.colors.color9'  "$WAL_CACHE_JSON")"
c10="$(jq -r '.colors.color10' "$WAL_CACHE_JSON")"
c11="$(jq -r '.colors.color11' "$WAL_CACHE_JSON")"
c12="$(jq -r '.colors.color12' "$WAL_CACHE_JSON")"
c13="$(jq -r '.colors.color13' "$WAL_CACHE_JSON")"
c14="$(jq -r '.colors.color14' "$WAL_CACHE_JSON")"
c15="$(jq -r '.colors.color15' "$WAL_CACHE_JSON")"

# Alias utili
accent="$c4"
accent2="$c6"
success="$c2"
warning="$c3"
danger="$c1"
muted="$c8"

# ===== Waybar (solo variabili CSS, non stili) =====
atomic_write "$WAYBAR_CSS" <<EOF
/* Generated by colors.sh — SOLO VARIABILI */
:root {
  --bg: ${bg};
  --fg: ${fg};
  --cursor: ${cursor};

  --color0:  ${c0};  --color1:  ${c1};  --color2:  ${c2};  --color3:  ${c3};
  --color4:  ${c4};  --color5:  ${c5};  --color6:  ${c6};  --color7:  ${c7};
  --color8:  ${c8};  --color9:  ${c9};  --color10: ${c10}; --color11: ${c11};
  --color12: ${c12}; --color13: ${c13}; --color14: ${c14}; --color15: ${c15};

  --accent:  ${accent};
  --accent2: ${accent2};
  --success: ${success};
  --warning: ${warning};
  --danger:  ${danger};
  --muted:   ${muted};
}
EOF

# ===== swaync (solo define-color, niente selettori) =====
atomic_write "$SWAYNC_CSS" <<EOF
/* Generated by colors.sh — define-color non invasivi */
@define-color bg ${bg};
@define-color fg ${fg};
@define-color cursor ${cursor};

@define-color color0 ${c0};
@define-color color1 ${c1};
@define-color color2 ${c2};
@define-color color3 ${c3};
@define-color color4 ${c4};
@define-color color5 ${c5};
@define-color color6 ${c6};
@define-color color7 ${c7};
@define-color color8 ${c8};
@define-color color9 ${c9};
@define-color color10 ${c10};
@define-color color11 ${c11};
@define-color color12 ${c12};
@define-color color13 ${c13};
@define-color color14 ${c14};
@define-color color15 ${c15};

@define-color accent ${accent};
@define-color accent2 ${accent2};
@define-color success ${success};
@define-color warning ${warning};
@define-color danger  ${danger};
@define-color muted   ${muted};
EOF

# ===== wlogout (solo variabili CSS root, per riuso nei temi) =====
atomic_write "$WLOGOUT_CSS" <<EOF
/* Generated by colors.sh — SOLO VARIABILI */
:root {
  --bg: ${bg};
  --fg: ${fg};
  --accent: ${accent};
  --muted: ${muted};
  --success: ${success};
  --warning: ${warning};
  --danger: ${danger};

  --color0: ${c0}; --color1: ${c1}; --color2: ${c2}; --color3: ${c3};
  --color4: ${c4}; --color5: ${c5}; --color6: ${c6}; --color7: ${c7};
  --color8: ${c8}; --color9: ${c9}; --color10: ${c10}; --color11: ${c11};
  --color12: ${c12}; --color13: ${c13}; --color14: ${c14}; --color15: ${c15};
}
EOF

# ===== Rofi
# Regola d'oro per non rompere:
# - Se colors.rasi NON esiste -> lo creiamo e importiamo il file wal.
# - Se colors.rasi ESISTE ma contiene il nostro header -> lo aggiorniamo.
# - Se colors.rasi ESISTE ed è personalizzato -> NON LO TOCCHIAMO.
ROFI_HEADER="# Generated by colors.sh (safe rofi import)"
update_rofi=false
if [[ ! -f "$ROFI_RASI" ]]; then
  update_rofi=true
elif grep -qF "$ROFI_HEADER" "$ROFI_RASI"; then
  update_rofi=true
fi
if $update_rofi; then
  # usa automaticamente il tema dark di wal se presente, altrimenti light
  rofi_base="$WAL_ROFI_RASI_DARK"
  [[ -f "$rofi_base" ]] || rofi_base="$WAL_ROFI_RASI_LIGHT"
  atomic_write "$ROFI_RASI" <<EOF
${ROFI_HEADER}
@import "${rofi_base}"
/* Qui puoi aggiungere override non invasivi, es:
* {
  /* font: "Fira Sans Semibold 11"; */
}
*/
EOF
else
  echo "[INFO] Rofi colors.rasi è personalizzato: non lo tocco."
fi

# ===== Hyprland colors.conf (solo variabili) =====
rgb_bg="$(hex_to_rgb_triplet "$bg")"
rgb_fg="$(hex_to_rgb_triplet "$fg")"
rgb_cursor="$(hex_to_rgb_triplet "$cursor")"

rgb0="$(hex_to_rgb_triplet "$c0")";   rgb1="$(hex_to_rgb_triplet "$c1")"
rgb2="$(hex_to_rgb_triplet "$c2")";   rgb3="$(hex_to_rgb_triplet "$c3")"
rgb4="$(hex_to_rgb_triplet "$c4")";   rgb5="$(hex_to_rgb_triplet "$c5")"
rgb6="$(hex_to_rgb_triplet "$c6")";   rgb7="$(hex_to_rgb_triplet "$c7")"
rgb8="$(hex_to_rgb_triplet "$c8")";   rgb9="$(hex_to_rgb_triplet "$c9")"
rgb10="$(hex_to_rgb_triplet "$c10")"; rgb11="$(hex_to_rgb_triplet "$c11")"
rgb12="$(hex_to_rgb_triplet "$c12")"; rgb13="$(hex_to_rgb_triplet "$c13")"
rgb14="$(hex_to_rgb_triplet "$c14")"; rgb15="$(hex_to_rgb_triplet "$c15")"

atomic_write "$HYPR_CONF" <<EOF
# Generated by colors.sh — SOLO variabili, nessun bind/stile
\$bg = rgb(${rgb_bg})
\$fg = rgb(${rgb_fg})
\$cursor = rgb(${rgb_cursor})

\$color0  = rgb(${rgb0})
\$color1  = rgb(${rgb1})
\$color2  = rgb(${rgb2})
\$color3  = rgb(${rgb3})
\$color4  = rgb(${rgb4})
\$color5  = rgb(${rgb5})
\$color6  = rgb(${rgb6})
\$color7  = rgb(${rgb7})
\$color8  = rgb(${rgb8})
\$color9  = rgb(${rgb9})
\$color10 = rgb(${rgb10})
\$color11 = rgb(${rgb11})
\$color12 = rgb(${rgb12})
\$color13 = rgb(${rgb13})
\$color14 = rgb(${rgb14})
\$color15 = rgb(${rgb15})

# Alias
\$accent  = rgb(${rgb4})
\$accent2 = rgb(${rgb6})
\$success = rgb(${rgb2})
\$warning = rgb(${rgb3})
\$danger  = rgb(${rgb1})
\$muted   = rgb(${rgb8})
EOF

# ===== Quickshell JSON (compatibile QML) =====
mkdir -p "$(dirname "$QS_JSON")"
jq -n --argjson src "$(cat "$WAL_CACHE_JSON")" \
'{
  special: {
    background: $src.special.background,
    foreground: $src.special.foreground,
    cursor:     $src.special.cursor
  },
  colors: {
    color0:  $src.colors.color0,  color1:  $src.colors.color1,
    color2:  $src.colors.color2,  color3:  $src.colors.color3,
    color4:  $src.colors.color4,  color5:  $src.colors.color5,
    color6:  $src.colors.color6,  color7:  $src.colors.color7,
    color8:  $src.colors.color8,  color9:  $src.colors.color9,
    color10: $src.colors.color10, color11: $src.colors.color11,
    color12: $src.colors.color12, color13: $src.colors.color13,
    color14: $src.colors.color14, color15: $src.colors.color15
  },
  quickshell: {
    bg:       $src.special.background,
    fg:       $src.special.foreground,
    accent:   $src.colors.color4,
    accent2:  $src.colors.color6,
    success:  $src.colors.color2,
    warning:  $src.colors.color3,
    danger:   $src.colors.color1,
    muted:    $src.colors.color8
  }
}' > "$QS_JSON"

echo "[OK] Quickshell palette scritta in: $QS_JSON"

# ===== Hook tuoi script/icon recolor =====
if [[ -x "$HOME/.config/waybar/scripts/svg-color-switcher-openai.sh" ]]; then
  "$HOME/.config/waybar/scripts/svg-color-switcher-openai.sh" "$c4" || true
fi
if [[ -x "$HOME/.config/waybar/scripts/svg-color-switcher-obsidian.sh" ]]; then
  "$HOME/.config/waybar/scripts/svg-color-switcher-obsidian.sh" "$c4" || true
fi

# ===== Reload Hyprland (se presente) =====
if [[ -x "$HOME/.config/hypr/scripts/reload.sh" ]]; then
  "$HOME/.config/hypr/scripts/reload.sh" || true
fi

echo "[colors.sh] Aggiornamento completato."
